import sys
import ast
from functools import reduce
from itertools import chain, combinations 
from .utils import get_key, get_set

class Topology:
    
    """ This class defines an object Topology """
    
   
    def __init__(self, E, S = None):
        """
        This is the constructor for Topology.

        Args:
            E (list/dictionary): List of pieces of evidence / Dictionary with pieces of evidence as keys and certainty degree as values.
            S (set, optional): Total set. 

        Returns:
            None
        """

        if E is None:
            raise ValueError("E (Evidence) argument must be provided.")

        if isinstance(E, dict):
            E = [get_set(k) for k in E.keys()]

        if S is None:
            S = set().union(*E)

        self.S = S
        self.E = E
    
    
    def get_subbasis(self):
        """
        This methods returns the subbasis of the topology generated by a collection of pieces of evidence. This is exactly the list of pieces of evidence. 

        Returns:
            E (list):   Evidence
        """
        
        return self.E
    
    def get_basis(self):
        """
        This method computes the basis of the topology generated by the evidence. Namely, the closure by finite intersections of the subbais.
        
        Returns:
            basis (list) : The basis of the topology.
        """
        
        basis = self.get_subbasis() # list of sets
        updated = True

        while updated:
            updated = False  # Set to False initially

        for (s1, s2) in combinations(basis, 2):
            inter = s1.intersection(s2)
            if inter not in basis:
                basis.append(inter)
                updated = True

        return basis

    def get_topology(self):
        """
        This methods returns the topology generated by the evidence. Namely, the closure by finite intersections and unions of the basis, plus the empty set and the total set.

        Returns:
            topology (list) : The topology.
        """

        basis = self.get_basis()
        topology = basis  # Initialize the topology with the basis elements

        # Add the empty set
        if set() not in topology:
            topology.append(set())

        # Add the total set
        if self.S not in topology:
            topology.append(self.S) 
        
        updated = True

        while updated:
            updated = False

            for size in range(2, len(basis) + 1):
                combinations_size = combinations(basis, size) # Generate all combinations of size 'size' from the basis elements

                for combination in combinations_size:
                    union = set().union(*combination)  # Compute the union of the combination elements
                    if union not in topology:
                        topology.append(union)  # Add the union to the topology
                        updated = True

        return topology

    def get_dense_sets(self):
        """
        This method computes the set of dense elements of the topology. 
        A set T is dense in the topology if (i) it belongs to the topology 
        and (ii) has a non-empty intersection with every non-empty set in the topology.

        Returns:
            dense_sets (list) : The set of dense sets of the topology.
        """
        topology = self.get_topology()
        topology.remove(set())
        dense_sets = []

        for candidate_set in topology:
            is_dense = True

            for other_set in topology:
                if not candidate_set.intersection(other_set): # Check all possible intersections
                    is_dense = False
                    break

            if is_dense:
                dense_sets.append(candidate_set)

        return dense_sets        


    def print(self):
        """
        This methods prints all the methods of the Topology class.

        Returns:
            None
        """

        print("Subbasis: " + str(self.get_subbasis()))
        print("Basis: " + str(self.get_basis()))
        print("Topology: ", str(self.get_topology()))
        print("Dense sets: ", str(self.get_dense_sets()))
        
    
def minimal_dense_set(sets):
    """
    This function computes the smallest dense set of a topology generated from a list of sets.
    A set S is dense if (i) it belongs to the topology and (ii) has a non-empty intersection with every set in the topology.

    Args:
        sets (list): A list of pieces of evidence.

    Returns:
        (set): The smallest dense set of the topology.
    """
    topology = Topology(sets)

    dense_sets = topology.get_dense_sets()

    return min(dense_sets, key=len, default=topology.S)